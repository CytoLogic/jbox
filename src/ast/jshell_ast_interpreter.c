/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <wordexp.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#include "utils/jbox_utils.h"
#include "jshell/jshell.h"
#include "jshell/jshell_ai.h"
#include "Parser.h"
#include "Absyn.h"

#include "jshell_ast_interpreter.h"
#include "jshell_ast_helpers.h"

/* Forward declarations of private functions */
void visitListJob(ListJob p);
void visitJob(Job p);
JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type);
JShellCmdVector* visitCommandPart(CommandPart p);
JShellCmdParams visitCommandUnit(CommandUnit p);
int visitOptionalInputRedirection(OptionalInputRedirection p);
int visitOptionalOutputRedirection(OptionalOutputRedirection p);
int visitListShellToken(ListShellToken p, wordexp_t* word_vector_ptr);
int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr);
int visitExpansionStringToken(ExpansionStringToken p, 
                              wordexp_t* word_vector_ptr);
int visitLiteralStringToken(LiteralStringToken p, 
                            wordexp_t* word_vector_ptr);
int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr);
int visitWordToken(WordToken p, wordexp_t* word_vector_ptr);
void visitAIQueryToken(AIQueryToken p);
void visitAIExecToken(AIExecToken p);
void visitIdent(Ident i);
void visitInteger(Integer i);
void visitDouble(Double d);
void visitChar(Char c);
void visitString(String s);


int interpretInput(Input p)
{
  DPRINT("visiting_Input");
  switch(p->kind)
  {
  case is_In:
    visitListJob(p->u.in_.listjob_);
    return 0;

  default:
    fprintf(stderr, "Error: bad kind field when printing Input!\n");
    exit(1);
  }
}


void visitListJob(ListJob listjob)
{
  DPRINT("visiting ListJob");
  while(listjob != 0)
  {
    visitJob(listjob->job_);
    listjob = listjob->listjob_;
  }
}


void visitJob(Job p)
{
  DPRINT("visiting Job");
  
  switch(p->kind)
  {
  case is_AssigJob:
    DPRINT("is AssigJob");
    {
      wordexp_t var_name_expansion = {0};
      int result = 
        visitShellToken(p->u.assigJob_.shelltoken_, &var_name_expansion);
      
      if (result != 0 || var_name_expansion.we_wordc != 1) {
        fprintf(stderr, "Error: invalid variable name in assignment\n");
        wordfree(&var_name_expansion);
        break;
      }
      
      char* var_name = var_name_expansion.we_wordv[0];
      DPRINT("Assignment variable name: %s", var_name);
      
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.assigJob_.commandline_, FG_JOB);
      
      if (exec_job != NULL) {
        char* captured_output = jshell_capture_and_tee_output(exec_job);
        
        if (captured_output != NULL) {
          jshell_set_env_var(var_name, captured_output);
          free(captured_output);
        } else {
          fprintf(stderr, "Error: failed to capture command output\n");
        }
        
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
      
      wordfree(&var_name_expansion);
    }
    break;
    
  case is_FGJob:
    DPRINT("is FGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.fGJob_.commandline_, FG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
    }
    break;
    
  case is_BGJob:
    DPRINT("is BGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.bGJob_.commandline_, BG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
    }
    break;
    
  case is_AIChatJob:
    DPRINT("is AIChatJob");
    visitAIQueryToken(p->u.aIChatJob_.aiquerytoken_);
    break;
    
  case is_AIExecJob:
    DPRINT("is AIExecJob");
    visitAIExecToken(p->u.aIExecJob_.aiexectoken_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Job!\n");
    exit(1);
  }
}


JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type)
{
  DPRINT("visiting CommandLine");

  switch(p->kind)
  {
  case is_CmdLine:
    {
      int input_fd =
        visitOptionalInputRedirection(
          p->u.cmdLine_.optionalinputredirection_);

      // Check for redirection error (-2 means error, -1 means no redirection)
      if (input_fd == -2) {
        jshell_set_last_exit_status(1);
        return NULL;
      }

      JShellCmdVector* cmd_vector =
        visitCommandPart(p->u.cmdLine_.commandpart_);

      int output_fd =
        visitOptionalOutputRedirection(
          p->u.cmdLine_.optionaloutputredirection_);

      // Check for output redirection error
      if (output_fd == -2) {
        if (input_fd != -1) close(input_fd);
        if (cmd_vector != NULL) {
          jshell_cleanup_cmd_vector(cmd_vector);
          free(cmd_vector);
        }
        jshell_set_last_exit_status(1);
        return NULL;
      }

      if (cmd_vector == NULL) {
        if (input_fd != -1) close(input_fd);
        if (output_fd != -1) close(output_fd);
        return NULL;
      }

      JShellExecJob* exec_job = malloc(sizeof(JShellExecJob));
      if (exec_job == NULL) {
        perror("malloc JShellExecJob");
        if (input_fd != -1) close(input_fd);
        if (output_fd != -1) close(output_fd);
        jshell_cleanup_cmd_vector(cmd_vector);
        free(cmd_vector);
        return NULL;
      }

      exec_job->exec_job_type = job_type;
      exec_job->jshell_cmd_vector_ptr = cmd_vector;
      exec_job->input_fd = input_fd;
      exec_job->output_fd = output_fd;

      DPRINT("Built JShellExecJob: type=%d, cmd_count=%zu, input_fd=%d, "
             "output_fd=%d",
             job_type, cmd_vector->cmd_count, input_fd, output_fd);

      return exec_job;
    }
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandLine!\n");
    exit(1);
  }
}


JShellCmdVector* visitCommandPart(CommandPart p)
{
  DPRINT("visiting CommandPart");
  
  size_t cmd_count = 0;
  CommandPart temp = p;
  
  while (temp != NULL) {
    cmd_count++;
    if (temp->kind == is_SnglCmd) {
      break;
    } else if (temp->kind == is_PipeCmd) {
      temp = temp->u.pipeCmd_.commandpart_;
    } else {
      fprintf(stderr, "Error: unexpected CommandPart kind!\n");
      return NULL;
    }
  }
  
  DPRINT("cmd_count = %zu", cmd_count);
  
  JShellCmdVector* cmd_vector = malloc(sizeof(JShellCmdVector));
  if (cmd_vector == NULL) {
    perror("malloc JShellCmdVector");
    return NULL;
  }
  
  cmd_vector->cmd_count = cmd_count;
  cmd_vector->jshell_cmd_params_ptr = 
    malloc(sizeof(JShellCmdParams) * cmd_count);
  if (cmd_vector->jshell_cmd_params_ptr == NULL) {
    perror("malloc JShellCmdParams array");
    free(cmd_vector);
    return NULL;
  }
  
  size_t index = 0;
  temp = p;
  
  while (temp != NULL && index < cmd_count) {
    if (temp->kind == is_SnglCmd) {
      DPRINT("is SnglCmd at index %zu", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.snglCmd_.commandunit_);
      break;
    } else if (temp->kind == is_PipeCmd) {
      DPRINT("is PipeCmd at index %zu", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.pipeCmd_.commandunit_);
      index++;
      temp = temp->u.pipeCmd_.commandpart_;
    }
  }
  
  return cmd_vector;
}


int visitOptionalInputRedirection(OptionalInputRedirection p)
{
  DPRINT("visiting OptionalInputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoInRedir:
    DPRINT("is NoInRedir");
    return -1;
    
  case is_InRedir:
    DPRINT("is InRedir");
    {
      int result =
        visitShellToken(p->u.inRedir_.shelltoken_, &word_vector);
      DPRINT("wordexp result: %d", result);

      if (result != 0 || word_vector.we_wordc != 1) {
        fprintf(stderr, "jshell: invalid input redirection\n");
        wordfree(&word_vector);
        return -2;  // -2 indicates error (vs -1 for no redirection)
      }

      DPRINT("Opening input file: %s", word_vector.we_wordv[0]);
      int fd = open(word_vector.we_wordv[0], O_RDONLY);
      if (fd == -1) {
        fprintf(stderr, "jshell: %s: %s\n", word_vector.we_wordv[0],
                strerror(errno));
        wordfree(&word_vector);
        return -2;  // -2 indicates error
      }
      DPRINT("Opened input file: fd=%d", fd);

      wordfree(&word_vector);
      return fd;
    }

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing "
            "OptionalInputRedirection!\n");
    exit(1);
  }
}


int visitOptionalOutputRedirection(OptionalOutputRedirection p)
{
  DPRINT("visiting OptionalOutputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoOutRedir:
    DPRINT("is NoOutRedir");
    return -1;
    
  case is_OutRedir:
    DPRINT("is OutRedir");
    {
      int result =
        visitShellToken(p->u.outRedir_.shelltoken_, &word_vector);
      DPRINT("wordexp result: %d", result);

      if (result != 0 || word_vector.we_wordc != 1) {
        fprintf(stderr, "jshell: invalid output redirection\n");
        wordfree(&word_vector);
        return -2;  // -2 indicates error (vs -1 for no redirection)
      }

      DPRINT("Opening output file: %s", word_vector.we_wordv[0]);
      int fd = open(word_vector.we_wordv[0],
                    O_WRONLY | O_CREAT | O_TRUNC,
                    0644);
      if (fd == -1) {
        fprintf(stderr, "jshell: %s: %s\n", word_vector.we_wordv[0],
                strerror(errno));
        wordfree(&word_vector);
        return -2;  // -2 indicates error
      }
      DPRINT("Opened output file: fd=%d", fd);

      wordfree(&word_vector);
      return fd;
    }

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing "
            "OptionalOutputRedirection!\n");
    exit(1);
  }
}


JShellCmdParams visitCommandUnit(CommandUnit p)
{
  DPRINT("visiting CommandUnit");

  JShellCmdParams cmd_params;
  memset(&cmd_params, 0, sizeof(JShellCmdParams));

  switch(p->kind)
  {
  case is_CmdUnit:
    {
      int result = 
        visitListShellToken(p->u.cmdUnit_.listshelltoken_, 
                           &cmd_params.word_expansion);

      DPRINT("wordexp result: %d", result);

      if (result == 0) {
        cmd_params.argc = (int)cmd_params.word_expansion.we_wordc;
        cmd_params.argv = cmd_params.word_expansion.we_wordv;
        
        DPRINT("Built JShellCmdParams: argc=%d", cmd_params.argc);
        for (int i = 0; i < cmd_params.argc; i++) {
          DPRINT("  argv[%d]=%s", i, cmd_params.argv[i]);
        }
      } else {
        fprintf(stderr, "Error: word expansion failed with code %d\n", 
                result);
        cmd_params.argc = 0;
        cmd_params.argv = NULL;
      }
      
      return cmd_params;
    }

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandUnit!\n");
    exit(1);
  }
}


int visitListShellToken(ListShellToken listshelltoken, 
                        wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ListShellToken");

  int wordexp_result = 0;

  while(listshelltoken != 0)
  {
    wordexp_result = 
      visitShellToken(listshelltoken->shelltoken_, word_vector_ptr);
    if (wordexp_result != 0) {
      return wordexp_result;
    }

    listshelltoken = listshelltoken->listshelltoken_;
  }
  return wordexp_result;
}


int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ShellToken");

  switch(p->kind)
  {
  case is_ExpStr:
    return visitExpansionStringToken(p->u.expStr_.expansionstringtoken_, 
                                     word_vector_ptr);
  case is_LitStr:
    return visitLiteralStringToken(p->u.litStr_.literalstringtoken_, 
                                   word_vector_ptr);
  case is_Var:
    return visitVariableToken(p->u.var_.variabletoken_, word_vector_ptr);
  case is_Wrd:
    return visitWordToken(p->u.wrd_.wordtoken_, word_vector_ptr);

  default:
    fprintf(stderr, "Error: bad kind field when printing ShellToken!\n");
    exit(1);
  }
}


// Helper to replace $? with exit status in strings
static char* preprocess_special_vars(const char* str) {
  // Check if $? appears in the string
  const char* pos = strstr(str, "$?");
  if (pos == NULL) {
    return NULL;  // No preprocessing needed
  }

  // Calculate new string size
  char exit_str[16];
  snprintf(exit_str, sizeof(exit_str), "%d", jshell_get_last_exit_status());
  size_t exit_len = strlen(exit_str);

  // Count occurrences of $?
  int count = 0;
  const char* p = str;
  while ((p = strstr(p, "$?")) != NULL) {
    count++;
    p += 2;
  }

  size_t new_len = strlen(str) + count * (exit_len - 2) + 1;
  char* result = malloc(new_len);
  if (result == NULL) {
    return NULL;
  }

  char* dest = result;
  const char* src = str;
  while (*src) {
    if (src[0] == '$' && src[1] == '?') {
      strcpy(dest, exit_str);
      dest += exit_len;
      src += 2;
    } else {
      *dest++ = *src++;
    }
  }
  *dest = '\0';

  return result;
}


int visitExpansionStringToken(ExpansionStringToken p,
                              wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ExpansionStringToken: %s", p);

  // Preprocess to replace $? with exit code
  char* preprocessed = preprocess_special_vars(p);
  if (preprocessed != NULL) {
    int result = jshell_expand_word(preprocessed, word_vector_ptr);
    free(preprocessed);
    return result;
  }

  return jshell_expand_word(p, word_vector_ptr);
}


int visitLiteralStringToken(LiteralStringToken p, 
                            wordexp_t* word_vector_ptr)
{
  DPRINT("visiting LiteralStringToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting VariableToken: %s", p);

  // Handle special variables that aren't in environment
  if (strcmp(p, "$?") == 0) {
    // $? - last exit status
    char exit_str[16];
    snprintf(exit_str, sizeof(exit_str), "%d", jshell_get_last_exit_status());
    return jshell_expand_word(exit_str, word_vector_ptr);
  }

  return jshell_expand_word(p, word_vector_ptr);
}


int visitWordToken(WordToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting WordToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


void visitAIQueryToken(AIQueryToken p)
{
  DPRINT("visiting AIQueryToken: %s", p);

  /* Extract query (skip the '@' prefix) */
  const char *query = p + 1;

  /* Default to "Hi!" if empty */
  if (query[0] == '\0') {
    query = "Hi!";
  }

  if (!jshell_ai_available()) {
    fprintf(stderr, "AI features require an API key.\n");
    fprintf(stderr, "  Add GOOGLE_API_KEY=<your_key> to ~/.jshell/env\n");
    jshell_set_last_exit_status(1);
    return;
  }

  char *response = jshell_ai_chat(query);
  if (response != NULL) {
    printf("%s\n", response);
    free(response);
  }
}


void visitAIExecToken(AIExecToken p)
{
  DPRINT("visiting AIExecToken: %s", p);

  /* Extract query (skip the '@!' prefix) */
  const char *query = p + 2;

  if (!jshell_ai_available()) {
    fprintf(stderr, "AI features require an API key.\n");
    fprintf(stderr, "  Add GOOGLE_API_KEY=<your_key> to ~/.jshell/env\n");
    jshell_set_last_exit_status(1);
    return;
  }

  if (query[0] == '\0') {
    fprintf(stderr, "jshell: AI execute requires a query\n");
    return;
  }

  char *command = jshell_ai_execute_query(query);
  if (command == NULL) {
    fprintf(stderr, "jshell: AI failed to generate command\n");
    return;
  }

  printf("Proposed command: %s\n", command);
  printf("Execute? (Y/n): ");
  fflush(stdout);

  char response[16];
  if (fgets(response, sizeof(response), stdin) == NULL) {
    free(command);
    return;
  }

  /* Accept Y, y, or empty (default yes) */
  char c = response[0];
  if (c == 'n' || c == 'N') {
    printf("Cancelled.\n");
    free(command);
    return;
  }

  /* Parse and execute the command */
  Input parse_tree = psInput(command);
  if (parse_tree == NULL) {
    fprintf(stderr, "jshell: AI generated invalid command: %s\n", command);
    free(command);
    return;
  }

  interpretInput(parse_tree);
  free_Input(parse_tree);
  free(command);
}


void visitIdent(Ident i)
{
  DPRINT("visiting Ident: %s", i);
}


void visitInteger(Integer i)
{
  DPRINT("visiting Integer: %d", i);
}


void visitDouble(Double d)
{
  DPRINT("visiting Double: %f", d);
}


void visitChar(Char c)
{
  DPRINT("visiting Char: %c", c);
}


void visitString(String s)
{
  DPRINT("visiting String: %s", s);
}
