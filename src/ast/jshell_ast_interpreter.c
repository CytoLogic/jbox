/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <wordexp.h>
#include <fcntl.h>
#include <unistd.h>

#include "../jbox_debug.h"
#include "jshell_ast_interpreter.h"
#include "jshell_ast_helpers.h"

/* Forward declarations of private functions */
void visitListJob(ListJob p);
void visitJob(Job p);
JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type);
JShellCmdVector* visitCommandPart(CommandPart p);
JShellCmdParams visitCommandUnit(CommandUnit p);
int visitOptionalInputRedirection(OptionalInputRedirection p);
int visitOptionalOutputRedirection(OptionalOutputRedirection p);
int visitListShellToken(ListShellToken p, wordexp_t* word_vector_ptr);
int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr);
int visitExpansionStringToken(ExpansionStringToken p, 
                              wordexp_t* word_vector_ptr);
int visitLiteralStringToken(LiteralStringToken p, 
                            wordexp_t* word_vector_ptr);
int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr);
int visitWordToken(WordToken p, wordexp_t* word_vector_ptr);
void visitAIQueryToken(AIQueryToken p);
void visitAIExecToken(AIExecToken p);
void visitIdent(Ident i);
void visitInteger(Integer i);
void visitDouble(Double d);
void visitChar(Char c);
void visitString(String s);


int interpretInput(Input p)
{
  DPRINT("visiting_Input");
  switch(p->kind)
  {
  case is_In:
    visitListJob(p->u.in_.listjob_);
    return 0;

  default:
    fprintf(stderr, "Error: bad kind field when printing Input!\n");
    exit(1);
  }
}


void visitListJob(ListJob listjob)
{
  DPRINT("visiting ListJob");
  while(listjob != 0)
  {
    visitJob(listjob->job_);
    listjob = listjob->listjob_;
  }
}


void visitJob(Job p)
{
  DPRINT("visiting Job");
  
  switch(p->kind)
  {
  case is_AssigJob:
    DPRINT("is AssigJob");
    {
      wordexp_t var_name_expansion = {0};
      int result = 
        visitShellToken(p->u.assigJob_.shelltoken_, &var_name_expansion);
      
      if (result != 0 || var_name_expansion.we_wordc != 1) {
        fprintf(stderr, "Error: invalid variable name in assignment\n");
        wordfree(&var_name_expansion);
        break;
      }
      
      char* var_name = var_name_expansion.we_wordv[0];
      DPRINT("Assignment variable name: %s", var_name);
      
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.assigJob_.commandline_, FG_JOB);
      
      if (exec_job != NULL) {
        char* captured_output = jshell_capture_and_tee_output(exec_job);
        
        if (captured_output != NULL) {
          jshell_set_env_var(var_name, captured_output);
          free(captured_output);
        } else {
          fprintf(stderr, "Error: failed to capture command output\n");
        }
        
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
      
      wordfree(&var_name_expansion);
    }
    break;
    
  case is_FGJob:
    DPRINT("is FGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.fGJob_.commandline_, FG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
    }
    break;
    
  case is_BGJob:
    DPRINT("is BGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.bGJob_.commandline_, BG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
        free(exec_job);
      }
    }
    break;
    
  case is_AIChatJob:
    DPRINT("is AIChatJob");
    visitAIQueryToken(p->u.aIChatJob_.aiquerytoken_);
    break;
    
  case is_AIExecJob:
    DPRINT("is AIExecJob");
    visitAIExecToken(p->u.aIExecJob_.aiexectoken_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Job!\n");
    exit(1);
  }
}


JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type)
{
  DPRINT("visiting CommandLine");

  switch(p->kind)
  {
  case is_CmdLine:
    {
      int input_fd = 
        visitOptionalInputRedirection(
          p->u.cmdLine_.optionalinputredirection_);
      
      JShellCmdVector* cmd_vector = 
        visitCommandPart(p->u.cmdLine_.commandpart_);
      
      int output_fd = 
        visitOptionalOutputRedirection(
          p->u.cmdLine_.optionaloutputredirection_);
      
      if (cmd_vector == NULL) {
        if (input_fd != -1) close(input_fd);
        if (output_fd != -1) close(output_fd);
        return NULL;
      }
      
      JShellExecJob* exec_job = malloc(sizeof(JShellExecJob));
      if (exec_job == NULL) {
        perror("malloc JShellExecJob");
        if (input_fd != -1) close(input_fd);
        if (output_fd != -1) close(output_fd);
        jshell_cleanup_cmd_vector(cmd_vector);
        free(cmd_vector);
        return NULL;
      }
      
      exec_job->exec_job_type = job_type;
      exec_job->jshell_cmd_vector_ptr = cmd_vector;
      exec_job->input_fd = input_fd;
      exec_job->output_fd = output_fd;
      
      DPRINT("Built JShellExecJob: type=%d, cmd_count=%zu, input_fd=%d, "
             "output_fd=%d",
             job_type, cmd_vector->cmd_count, input_fd, output_fd);
      
      return exec_job;
    }
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandLine!\n");
    exit(1);
  }
}


JShellCmdVector* visitCommandPart(CommandPart p)
{
  DPRINT("visiting CommandPart");
  
  size_t cmd_count = 0;
  CommandPart temp = p;
  
  while (temp != NULL) {
    cmd_count++;
    if (temp->kind == is_SnglCmd) {
      break;
    } else if (temp->kind == is_PipeCmd) {
      temp = temp->u.pipeCmd_.commandpart_;
    } else {
      fprintf(stderr, "Error: unexpected CommandPart kind!\n");
      return NULL;
    }
  }
  
  DPRINT("cmd_count = %zu", cmd_count);
  
  JShellCmdVector* cmd_vector = malloc(sizeof(JShellCmdVector));
  if (cmd_vector == NULL) {
    perror("malloc JShellCmdVector");
    return NULL;
  }
  
  cmd_vector->cmd_count = cmd_count;
  cmd_vector->jshell_cmd_params_ptr = 
    malloc(sizeof(JShellCmdParams) * cmd_count);
  if (cmd_vector->jshell_cmd_params_ptr == NULL) {
    perror("malloc JShellCmdParams array");
    free(cmd_vector);
    return NULL;
  }
  
  size_t index = 0;
  temp = p;
  
  while (temp != NULL && index < cmd_count) {
    if (temp->kind == is_SnglCmd) {
      DPRINT("is SnglCmd at index %zu", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.snglCmd_.commandunit_);
      break;
    } else if (temp->kind == is_PipeCmd) {
      DPRINT("is PipeCmd at index %zu", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.pipeCmd_.commandunit_);
      index++;
      temp = temp->u.pipeCmd_.commandpart_;
    }
  }
  
  return cmd_vector;
}


int visitOptionalInputRedirection(OptionalInputRedirection p)
{
  DPRINT("visiting OptionalInputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoInRedir:
    DPRINT("is NoInRedir");
    return -1;
    
  case is_InRedir:
    DPRINT("is InRedir");
    {
      int result = 
        visitShellToken(p->u.inRedir_.shelltoken_, &word_vector);
      DPRINT("wordexp result: %d", result);
      
      if (result != 0 || word_vector.we_wordc != 1) {
        fprintf(stderr, "Error: invalid input redirection\n");
        wordfree(&word_vector);
        return -1;
      }
      
      DPRINT("Opening input file: %s", word_vector.we_wordv[0]);
      int fd = open(word_vector.we_wordv[0], O_RDONLY);
      if (fd == -1) {
        perror("open input file");
      } else {
        DPRINT("Opened input file: fd=%d", fd);
      }
      
      wordfree(&word_vector);
      return fd;
    }

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing "
            "OptionalInputRedirection!\n");
    exit(1);
  }
}


int visitOptionalOutputRedirection(OptionalOutputRedirection p)
{
  DPRINT("visiting OptionalOutputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoOutRedir:
    DPRINT("is NoOutRedir");
    return -1;
    
  case is_OutRedir:
    DPRINT("is OutRedir");
    {
      int result = 
        visitShellToken(p->u.outRedir_.shelltoken_, &word_vector);
      DPRINT("wordexp result: %d", result);
      
      if (result != 0 || word_vector.we_wordc != 1) {
        fprintf(stderr, "Error: invalid output redirection\n");
        wordfree(&word_vector);
        return -1;
      }
      
      DPRINT("Opening output file: %s", word_vector.we_wordv[0]);
      int fd = open(word_vector.we_wordv[0], 
                    O_WRONLY | O_CREAT | O_TRUNC, 
                    0644);
      if (fd == -1) {
        perror("open output file");
      } else {
        DPRINT("Opened output file: fd=%d", fd);
      }
      
      wordfree(&word_vector);
      return fd;
    }

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing "
            "OptionalOutputRedirection!\n");
    exit(1);
  }
}


JShellCmdParams visitCommandUnit(CommandUnit p)
{
  DPRINT("visiting CommandUnit");

  JShellCmdParams cmd_params;
  memset(&cmd_params, 0, sizeof(JShellCmdParams));

  switch(p->kind)
  {
  case is_CmdUnit:
    {
      int result = 
        visitListShellToken(p->u.cmdUnit_.listshelltoken_, 
                           &cmd_params.word_expansion);

      DPRINT("wordexp result: %d", result);

      if (result == 0) {
        cmd_params.argc = (int)cmd_params.word_expansion.we_wordc;
        cmd_params.argv = cmd_params.word_expansion.we_wordv;
        
        DPRINT("Built JShellCmdParams: argc=%d", cmd_params.argc);
        for (int i = 0; i < cmd_params.argc; i++) {
          DPRINT("  argv[%d]=%s", i, cmd_params.argv[i]);
        }
      } else {
        fprintf(stderr, "Error: word expansion failed with code %d\n", 
                result);
        cmd_params.argc = 0;
        cmd_params.argv = NULL;
      }
      
      return cmd_params;
    }

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandUnit!\n");
    exit(1);
  }
}


int visitListShellToken(ListShellToken listshelltoken, 
                        wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ListShellToken");

  int wordexp_result = 0;

  while(listshelltoken != 0)
  {
    wordexp_result = 
      visitShellToken(listshelltoken->shelltoken_, word_vector_ptr);
    if (wordexp_result != 0) {
      return wordexp_result;
    }

    listshelltoken = listshelltoken->listshelltoken_;
  }
  return wordexp_result;
}


int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ShellToken");

  switch(p->kind)
  {
  case is_ExpStr:
    return visitExpansionStringToken(p->u.expStr_.expansionstringtoken_, 
                                     word_vector_ptr);
  case is_LitStr:
    return visitLiteralStringToken(p->u.litStr_.literalstringtoken_, 
                                   word_vector_ptr);
  case is_Var:
    return visitVariableToken(p->u.var_.variabletoken_, word_vector_ptr);
  case is_Wrd:
    return visitWordToken(p->u.wrd_.wordtoken_, word_vector_ptr);

  default:
    fprintf(stderr, "Error: bad kind field when printing ShellToken!\n");
    exit(1);
  }
}


int visitExpansionStringToken(ExpansionStringToken p, 
                              wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ExpansionStringToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


int visitLiteralStringToken(LiteralStringToken p, 
                            wordexp_t* word_vector_ptr)
{
  DPRINT("visiting LiteralStringToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting VariableToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


int visitWordToken(WordToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting WordToken: %s", p);
  return jshell_expand_word(p, word_vector_ptr);
}


void visitAIQueryToken(AIQueryToken p)
{
  DPRINT("visiting AIQueryToken: %s", p);
  printf("AI Query: %s\n", p);
}


void visitAIExecToken(AIExecToken p)
{
  DPRINT("visiting AIExecToken: %s", p);
  printf("AI Exec: %s\n", p);
}


void visitIdent(Ident i)
{
  DPRINT("visiting Ident: %s", i);
}


void visitInteger(Integer i)
{
  DPRINT("visiting Integer: %d", i);
}


void visitDouble(Double d)
{
  DPRINT("visiting Double: %f", d);
}


void visitChar(Char c)
{
  DPRINT("visiting Char: %c", c);
}


void visitString(String s)
{
  DPRINT("visiting String: %s", s);
}
