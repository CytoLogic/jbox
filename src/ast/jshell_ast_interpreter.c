/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#include <stdlib.h>
#include <stdio.h>
#include <wordexp.h>
#include <fcntl.h>
#include <unistd.h>

#include "jbox_debug.h"
#include "jshell_ast_interpreter.h"
#include "jshell_ast_helpers.h"

// forward declarations of private functions
void visitListJob(ListJob p);
void visitJob(Job p);
JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type);
JShellCmdVector* visitCommandPart(CommandPart p);
JShellCmdParams visitCommandUnit(CommandUnit p);
int visitOptionalInputRedirection(OptionalInputRedirection p);
int visitOptionalOutputRedirection(OptionalOutputRedirection p);
int visitListShellToken(ListShellToken p, wordexp_t* word_vector_ptr);
int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr);
int visitExpansionStringToken(ExpansionStringToken p, wordexp_t* word_vector_ptr);
int visitLiteralStringToken(LiteralStringToken p, wordexp_t* word_vector_ptr);
int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr);
int visitWordToken(WordToken p, wordexp_t* word_vector_ptr);
void visitAIQueryToken(AIQueryToken p);
void visitAIExecToken(AIExecToken p);
void visitIdent(Ident i);
void visitInteger(Integer i);
void visitDouble(Double d);
void visitChar(Char c);
void visitString(String s);


int interpretInput(Input p)
{
  DPRINT("visiting_Input");
  switch(p->kind)
  {
  case is_In:
    /* Code for In Goes Here */
    visitListJob(p->u.in_.listjob_);
    return 0;

  default:
    fprintf(stderr, "Error: bad kind field when printing Input!\n");
    exit(1);
  }
}


void visitListJob(ListJob listjob)
{
  DPRINT("visiting ListJob");
  while(listjob  != 0)
  {
    /* Code For ListJob Goes Here */
    visitJob(listjob->job_);
    listjob = listjob->listjob_;
  }
}


void visitJob(Job p)
{
  DPRINT("visiting Job");
  
  switch(p->kind)
  {
  case is_AssigJob:
    DPRINT("is AssigJob");
    // TODO: Phase 4 - Handle assignment jobs
    visitShellToken(p->u.assigJob_.shelltoken_, NULL);
    visitCommandLine(p->u.assigJob_.commandline_, FG_JOB);
    break;
    
  case is_FGJob:
    DPRINT("is FGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.fGJob_.commandline_, FG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
      }
    }
    break;
    
  case is_BGJob:
    DPRINT("is BGJob");
    {
      JShellExecJob* exec_job = 
        visitCommandLine(p->u.bGJob_.commandline_, BG_JOB);
      if (exec_job != NULL) {
        jshell_exec_job(exec_job);
        jshell_cleanup_job(exec_job);
      }
    }
    break;
    
  case is_AIChatJob:
    DPRINT("is AIChatJob");
    visitAIQueryToken(p->u.aIChatJob_.aiquerytoken_);
    break;
    
  case is_AIExecJob:
    DPRINT("is AIExecJob");
    visitAIExecToken(p->u.aIExecJob_.aiexectoken_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Job!\n");
    exit(1);
  }
}

JShellExecJob* visitCommandLine(CommandLine p, ExecJobType job_type)
{
  DPRINT("visiting CommandLine");

  switch(p->kind)
  {
  case is_CmdLine:
    {
      // Build command vector
      JShellCmdVector* cmd_vector = 
        visitCommandPart(p->u.cmdLine_.commandpart_);
      
      // Get input/output file descriptors
      int input_fd = 
        visitOptionalInputRedirection(
          p->u.cmdLine_.optionalinputredirection_);
      int output_fd = 
        visitOptionalOutputRedirection(
          p->u.cmdLine_.optionaloutputredirection_);
      
      // Allocate and populate JShellExecJob
      JShellExecJob* exec_job = malloc(sizeof(JShellExecJob));
      if (exec_job == NULL) {
        perror("malloc JShellExecJob");
        // Clean up file descriptors
        if (input_fd != -1) close(input_fd);
        if (output_fd != -1) close(output_fd);
        // TODO: Clean up cmd_vector
        return NULL;
      }
      
      exec_job->exec_job_type = job_type;
      exec_job->jshell_cmd_vector_ptr = cmd_vector;
      exec_job->input_fd = input_fd;
      exec_job->output_fd = output_fd;
      
      DPRINT("Built JShellExecJob: type=%d, cmd_count=%zu, input_fd=%d, \
output_fd=%d",
             job_type, cmd_vector->cmd_count, input_fd, output_fd);
      
      return exec_job;
    }
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandLine!\n");
    exit(1);
  }
}

JShellCmdVector* visitCommandPart(CommandPart p)
{
  DPRINT("visiting CommandPart");
  
  // First pass: count commands
  int cmd_count = 0;
  CommandPart temp = p;
  while (temp != NULL) {
    cmd_count++;
    if (temp->kind == is_SnglCmd) {
      break;
    } else if (temp->kind == is_PipeCmd) {
      temp = temp->u.pipeCmd_.commandpart_;
    }
  }
  
  DPRINT("cmd_count = %d", cmd_count);
  
  // Allocate JShellCmdVector
  JShellCmdVector* cmd_vector = malloc(sizeof(JShellCmdVector));
  if (cmd_vector == NULL) {
    perror("malloc JShellCmdVector");
    exit(EXIT_FAILURE);
  }
  
  cmd_vector->cmd_count = cmd_count;
  cmd_vector->jshell_cmd_params_ptr = 
    malloc(sizeof(JShellCmdParams) * cmd_count);
  if (cmd_vector->jshell_cmd_params_ptr == NULL) {
    perror("malloc JShellCmdParams array");
    free(cmd_vector);
    exit(EXIT_FAILURE);
  }
  
  // Second pass: populate commands (in reverse order due to grammar)
  int index = cmd_count - 1;
  temp = p;
  while (temp != NULL) {
    if (temp->kind == is_SnglCmd) {
      DPRINT("is SnglCmd at index %d", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.snglCmd_.commandunit_);
      break;
    } else if (temp->kind == is_PipeCmd) {
      DPRINT("is PipeCmd at index %d", index);
      cmd_vector->jshell_cmd_params_ptr[index] = 
        visitCommandUnit(temp->u.pipeCmd_.commandunit_);
      index--;
      temp = temp->u.pipeCmd_.commandpart_;
    }
  }
  
  return cmd_vector;
}

int visitOptionalInputRedirection(OptionalInputRedirection p)
{
  DPRINT("visiting OptionalInputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoInRedir:
    DPRINT("is NoInRedir");
    return -1;
    
  case is_InRedir:
    DPRINT("is InRedir");
    int result = visitShellToken(p->u.inRedir_.shelltoken_, &word_vector);
    DPRINT("wordexp result: %d", result);
    DPRINT_WORDEXP(word_vector);
    
    if (result != 0 || word_vector.we_wordc != 1) {
      fprintf(stderr, "Error: invalid input redirection\n");
      wordfree(&word_vector);
      return -1;
    }
    
    int fd = open(word_vector.we_wordv[0], O_RDONLY);
    if (fd == -1) {
      perror("open input file");
    }
    
    wordfree(&word_vector);
    return fd;

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing \
OptionalInputRedirection!\n");
    exit(1);
  }
}

int visitOptionalOutputRedirection(OptionalOutputRedirection p)
{
  DPRINT("visiting OptionalOutputRedirection");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_NoOutRedir:
    DPRINT("is NoOutRedir");
    return -1;
    
  case is_OutRedir:
    DPRINT("is OutRedir");
    int result = visitShellToken(p->u.outRedir_.shelltoken_, &word_vector);
    DPRINT("wordexp result: %d", result);
    DPRINT_WORDEXP(word_vector);
    
    if (result != 0 || word_vector.we_wordc != 1) {
      fprintf(stderr, "Error: invalid output redirection\n");
      wordfree(&word_vector);
      return -1;
    }
    
    int fd = open(word_vector.we_wordv[0], 
                  O_WRONLY | O_CREAT | O_TRUNC, 
                  0644);
    if (fd == -1) {
      perror("open output file");
    }
    
    wordfree(&word_vector);
    return fd;

  default:
    fprintf(stderr, 
            "Error: bad kind field when printing \
OptionalOutputRedirection!\n");
    exit(1);
  }
}

JShellCmdParams visitCommandUnit(CommandUnit p)
{
  DPRINT("visiting CommandUnit");

  wordexp_t word_vector = {0};

  switch(p->kind)
  {
  case is_CmdUnit:

    int result = 
      visitListShellToken(p->u.cmdUnit_.listshelltoken_, &word_vector);

    DPRINT("wordexp result: %d", result);
    DPRINT_WORDEXP(word_vector);

    JShellCmdParams cmd_params = {
      .argc = (int)word_vector.we_wordc,
      .argv = word_vector.we_wordv
    };
    return cmd_params;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandUnit!\n");
    exit(1);
  }
}

int visitListShellToken(ListShellToken listshelltoken, 
                        wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ListShellToken");

  int wordexp_result = 0;

  while(listshelltoken  != 0)
  {
    wordexp_result = 
      visitShellToken(listshelltoken->shelltoken_, word_vector_ptr);
    // return wordexp_result if it is nonzero
    if (wordexp_result != 0) {
      return wordexp_result;
    }

    listshelltoken = listshelltoken->listshelltoken_;
  }
  return wordexp_result;
}


int visitShellToken(ShellToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ShellToken");

  switch(p->kind)
  {
  case is_ExpStr:
    return visitExpansionStringToken(p->u.expStr_.expansionstringtoken_, 
                                     word_vector_ptr);
    break;
  case is_LitStr:
    return visitLiteralStringToken(p->u.litStr_.literalstringtoken_, 
                                   word_vector_ptr);
    break;
  case is_Var:
    return visitVariableToken(p->u.var_.variabletoken_, word_vector_ptr);
    break;
  case is_Wrd:
    return visitWordToken(p->u.wrd_.wordtoken_, word_vector_ptr);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing ShellToken!\n");
    exit(1);
  }
}

int visitExpansionStringToken(ExpansionStringToken p, 
                              wordexp_t* word_vector_ptr)
{
  DPRINT("visiting ExpansionStringToken");
  return jshell_expand_word(p, word_vector_ptr);
}

int visitLiteralStringToken(LiteralStringToken p, 
                            wordexp_t* word_vector_ptr)
{
  DPRINT("visiting LiteralStringToken");
  return jshell_expand_word(p, word_vector_ptr);
}

int visitVariableToken(VariableToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting VariableToken");
  return jshell_expand_word(p, word_vector_ptr);
}

int visitWordToken(WordToken p, wordexp_t* word_vector_ptr)
{
  DPRINT("visiting WordToken");
  return jshell_expand_word(p, word_vector_ptr);
}


void visitAIQueryToken(AIQueryToken p)
{
  DPRINT("visiting AIQueryToken");
  /* Code for AIQueryToken Goes Here */
}

void visitAIExecToken(AIExecToken p)
{
  DPRINT("visiting AIExecToken");
  /* Code for AIExecToken Goes Here */
}


// TODO: Trim Fat
void visitIdent(Ident i)
{
  /* Code for Ident Goes Here */
}

void visitInteger(Integer i)
{
  /* Code for Integer Goes Here */
}

void visitDouble(Double d)
{
  /* Code for Double Goes Here */
}

void visitChar(Char c)
{
  /* Code for Char Goes Here */
}

void visitString(String s)
{
  /* Code for String Goes Here */
}
