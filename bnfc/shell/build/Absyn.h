/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Word;

/********************   Forward Declarations    ***********************/
struct ListJob_;
typedef struct ListJob_ *ListJob;

struct Input_;
typedef struct Input_ *Input;

struct Job_;
typedef struct Job_ *Job;

struct CommandLine_;
typedef struct CommandLine_ *CommandLine;

struct Pipeline_;
typedef struct Pipeline_ *Pipeline;

struct ListWord_;
typedef struct ListWord_ *ListWord;

struct CommandPart_;
typedef struct CommandPart_ *CommandPart;

struct OptRedir_;
typedef struct OptRedir_ *OptRedir;

/********************   Abstract Syntax Classes    ********************/

struct ListJob_
{
  Job job_;
  ListJob listjob_;
};

ListJob make_ListJob(Job p1, ListJob p2);

struct Input_
{
  enum { is_StartInput } kind;
  union
  {
    struct { ListJob listjob_; } startInput_;
  } u;
};

Input make_StartInput(ListJob p0);

struct Job_
{
  enum { is_FGJob, is_BGJob } kind;
  union
  {
    struct { CommandLine commandline_; } fGJob_;
    struct { CommandLine commandline_; } bGJob_;
  } u;
};

Job make_FGJob(CommandLine p0);
Job make_BGJob(CommandLine p0);

struct CommandLine_
{
  enum { is_CmdLine } kind;
  union
  {
    struct { OptRedir optredir_; Pipeline pipeline_; } cmdLine_;
  } u;
};

CommandLine make_CmdLine(Pipeline p0, OptRedir p1);

struct Pipeline_
{
  enum { is_SingleCmd, is_PipeCmd } kind;
  union
  {
    struct { CommandPart commandpart_; } singleCmd_;
    struct { CommandPart commandpart_; Pipeline pipeline_; } pipeCmd_;
  } u;
};

Pipeline make_SingleCmd(CommandPart p0);
Pipeline make_PipeCmd(CommandPart p0, Pipeline p1);

struct ListWord_
{
  Word word_;
  ListWord listword_;
};

ListWord make_ListWord(Word p1, ListWord p2);

struct CommandPart_
{
  enum { is_Cmd } kind;
  union
  {
    struct { ListWord listword_; } cmd_;
  } u;
};

CommandPart make_Cmd(ListWord p0);

struct OptRedir_
{
  enum { is_NoRedir, is_InOutRedir, is_OutInRedir, is_OutRedir, is_InRedir } kind;
  union
  {
    struct { Word word_1, word_2; } inOutRedir_;
    struct { Word word_1, word_2; } outInRedir_;
    struct { Word word_; } outRedir_;
    struct { Word word_; } inRedir_;
  } u;
};

OptRedir make_NoRedir(void);
OptRedir make_InOutRedir(Word p0, Word p1);
OptRedir make_OutInRedir(Word p0, Word p1);
OptRedir make_OutRedir(Word p0);
OptRedir make_InRedir(Word p0);

/***************************   Cloning   ******************************/

ListJob clone_ListJob(ListJob p);
Input clone_Input(Input p);
Job clone_Job(Job p);
CommandLine clone_CommandLine(CommandLine p);
Pipeline clone_Pipeline(Pipeline p);
ListWord clone_ListWord(ListWord p);
CommandPart clone_CommandPart(CommandPart p);
OptRedir clone_OptRedir(OptRedir p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_ListJob(ListJob p);
void free_Input(Input p);
void free_Job(Job p);
void free_CommandLine(CommandLine p);
void free_Pipeline(Pipeline p);
void free_ListWord(ListWord p);
void free_CommandPart(CommandPart p);
void free_OptRedir(OptRedir p);


#endif
