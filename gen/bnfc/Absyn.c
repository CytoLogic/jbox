/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   ListJob    ********************/

ListJob make_ListJob(Job p1, ListJob p2)
{
    ListJob tmp = (ListJob) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListJob!\n");
        exit(1);
    }
    tmp->job_ = p1;
    tmp->listjob_ = p2;
    return tmp;
}

/********************   StartInput    ********************/

Input make_StartInput(ListJob p1)
{
    Input tmp = (Input) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StartInput!\n");
        exit(1);
    }
    tmp->kind = is_StartInput;
    tmp->u.startInput_.listjob_ = p1;
    return tmp;
}

/********************   FGJob    ********************/

Job make_FGJob(CommandLine p1)
{
    Job tmp = (Job) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FGJob!\n");
        exit(1);
    }
    tmp->kind = is_FGJob;
    tmp->u.fGJob_.commandline_ = p1;
    return tmp;
}

/********************   BGJob    ********************/

Job make_BGJob(CommandLine p1)
{
    Job tmp = (Job) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BGJob!\n");
        exit(1);
    }
    tmp->kind = is_BGJob;
    tmp->u.bGJob_.commandline_ = p1;
    return tmp;
}

/********************   CmdLine    ********************/

CommandLine make_CmdLine(Pipeline p1, OptRedir p2)
{
    CommandLine tmp = (CommandLine) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CmdLine!\n");
        exit(1);
    }
    tmp->kind = is_CmdLine;
    tmp->u.cmdLine_.pipeline_ = p1;
    tmp->u.cmdLine_.optredir_ = p2;
    return tmp;
}

/********************   SingleCmd    ********************/

Pipeline make_SingleCmd(CommandPart p1)
{
    Pipeline tmp = (Pipeline) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SingleCmd!\n");
        exit(1);
    }
    tmp->kind = is_SingleCmd;
    tmp->u.singleCmd_.commandpart_ = p1;
    return tmp;
}

/********************   PipeCmd    ********************/

Pipeline make_PipeCmd(CommandPart p1, Pipeline p2)
{
    Pipeline tmp = (Pipeline) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PipeCmd!\n");
        exit(1);
    }
    tmp->kind = is_PipeCmd;
    tmp->u.pipeCmd_.commandpart_ = p1;
    tmp->u.pipeCmd_.pipeline_ = p2;
    return tmp;
}

/********************   ListWord    ********************/

ListWord make_ListWord(Word p1, ListWord p2)
{
    ListWord tmp = (ListWord) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListWord!\n");
        exit(1);
    }
    tmp->word_ = p1;
    tmp->listword_ = p2;
    return tmp;
}

/********************   Cmd    ********************/

CommandPart make_Cmd(ListWord p1)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd!\n");
        exit(1);
    }
    tmp->kind = is_Cmd;
    tmp->u.cmd_.listword_ = p1;
    return tmp;
}

/********************   NoRedir    ********************/

OptRedir make_NoRedir()
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NoRedir!\n");
        exit(1);
    }
    tmp->kind = is_NoRedir;
    return tmp;
}

/********************   InOutRedir    ********************/

OptRedir make_InOutRedir(Word p1, Word p2)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InOutRedir!\n");
        exit(1);
    }
    tmp->kind = is_InOutRedir;
    tmp->u.inOutRedir_.word_1 = p1;
    tmp->u.inOutRedir_.word_2 = p2;
    return tmp;
}

/********************   OutInRedir    ********************/

OptRedir make_OutInRedir(Word p1, Word p2)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OutInRedir!\n");
        exit(1);
    }
    tmp->kind = is_OutInRedir;
    tmp->u.outInRedir_.word_1 = p1;
    tmp->u.outInRedir_.word_2 = p2;
    return tmp;
}

/********************   OutRedir    ********************/

OptRedir make_OutRedir(Word p1)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OutRedir!\n");
        exit(1);
    }
    tmp->kind = is_OutRedir;
    tmp->u.outRedir_.word_ = p1;
    return tmp;
}

/********************   InRedir    ********************/

OptRedir make_InRedir(Word p1)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InRedir!\n");
        exit(1);
    }
    tmp->kind = is_InRedir;
    tmp->u.inRedir_.word_ = p1;
    return tmp;
}

/***************************   Cloning   ******************************/

ListJob clone_ListJob(ListJob listjob)
{
  if (listjob)
  {
    /* clone of non-empty list */
    return make_ListJob
      ( clone_Job(listjob->job_)
      , clone_ListJob(listjob->listjob_)
      );
  }
  else return NULL; /* clone of empty list */
}

Input clone_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    return make_StartInput (clone_ListJob(p->u.startInput_.listjob_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Input!\n");
    exit(1);
  }
}

Job clone_Job(Job p)
{
  switch(p->kind)
  {
  case is_FGJob:
    return make_FGJob (clone_CommandLine(p->u.fGJob_.commandline_));

  case is_BGJob:
    return make_BGJob (clone_CommandLine(p->u.bGJob_.commandline_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Job!\n");
    exit(1);
  }
}

CommandLine clone_CommandLine(CommandLine p)
{
  switch(p->kind)
  {
  case is_CmdLine:
    return make_CmdLine
      ( clone_Pipeline(p->u.cmdLine_.pipeline_)
      , clone_OptRedir(p->u.cmdLine_.optredir_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CommandLine!\n");
    exit(1);
  }
}

Pipeline clone_Pipeline(Pipeline p)
{
  switch(p->kind)
  {
  case is_SingleCmd:
    return make_SingleCmd (clone_CommandPart(p->u.singleCmd_.commandpart_));

  case is_PipeCmd:
    return make_PipeCmd
      ( clone_CommandPart(p->u.pipeCmd_.commandpart_)
      , clone_Pipeline(p->u.pipeCmd_.pipeline_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Pipeline!\n");
    exit(1);
  }
}

ListWord clone_ListWord(ListWord listword)
{
  if (listword)
  {
    /* clone of non-empty list */
    return make_ListWord
      ( strdup(listword->word_)
      , clone_ListWord(listword->listword_)
      );
  }
  else return NULL; /* clone of empty list */
}

CommandPart clone_CommandPart(CommandPart p)
{
  switch(p->kind)
  {
  case is_Cmd:
    return make_Cmd (clone_ListWord(p->u.cmd_.listword_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CommandPart!\n");
    exit(1);
  }
}

OptRedir clone_OptRedir(OptRedir p)
{
  switch(p->kind)
  {
  case is_NoRedir:
    return make_NoRedir ();

  case is_InOutRedir:
    return make_InOutRedir
      ( strdup(p->u.inOutRedir_.word_1)
      , strdup(p->u.inOutRedir_.word_2)
      );

  case is_OutInRedir:
    return make_OutInRedir
      ( strdup(p->u.outInRedir_.word_1)
      , strdup(p->u.outInRedir_.word_2)
      );

  case is_OutRedir:
    return make_OutRedir (strdup(p->u.outRedir_.word_));

  case is_InRedir:
    return make_InRedir (strdup(p->u.inRedir_.word_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning OptRedir!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_ListJob(ListJob listjob)
{
  if (listjob)
  {
    free_Job(listjob->job_);
    free_ListJob(listjob->listjob_);
    free(listjob);
  }
}

void free_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    free_ListJob(p->u.startInput_.listjob_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Input!\n");
    exit(1);
  }
  free(p);
}

void free_Job(Job p)
{
  switch(p->kind)
  {
  case is_FGJob:
    free_CommandLine(p->u.fGJob_.commandline_);
    break;

  case is_BGJob:
    free_CommandLine(p->u.bGJob_.commandline_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Job!\n");
    exit(1);
  }
  free(p);
}

void free_CommandLine(CommandLine p)
{
  switch(p->kind)
  {
  case is_CmdLine:
    free_Pipeline(p->u.cmdLine_.pipeline_);
    free_OptRedir(p->u.cmdLine_.optredir_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CommandLine!\n");
    exit(1);
  }
  free(p);
}

void free_Pipeline(Pipeline p)
{
  switch(p->kind)
  {
  case is_SingleCmd:
    free_CommandPart(p->u.singleCmd_.commandpart_);
    break;

  case is_PipeCmd:
    free_CommandPart(p->u.pipeCmd_.commandpart_);
    free_Pipeline(p->u.pipeCmd_.pipeline_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Pipeline!\n");
    exit(1);
  }
  free(p);
}

void free_ListWord(ListWord listword)
{
  if (listword)
  {
    free(listword->word_);
    free_ListWord(listword->listword_);
    free(listword);
  }
}

void free_CommandPart(CommandPart p)
{
  switch(p->kind)
  {
  case is_Cmd:
    free_ListWord(p->u.cmd_.listword_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CommandPart!\n");
    exit(1);
  }
  free(p);
}

void free_OptRedir(OptRedir p)
{
  switch(p->kind)
  {
  case is_NoRedir:
    break;

  case is_InOutRedir:
    free(p->u.inOutRedir_.word_1);
    free(p->u.inOutRedir_.word_2);
    break;

  case is_OutInRedir:
    free(p->u.outInRedir_.word_1);
    free(p->u.outInRedir_.word_2);
    break;

  case is_OutRedir:
    free(p->u.outRedir_.word_);
    break;

  case is_InRedir:
    free(p->u.inRedir_.word_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OptRedir!\n");
    exit(1);
  }
  free(p);
}

