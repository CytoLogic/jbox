/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.6.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the grammar_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE grammar__scan_string(const char *str, yyscan_t scanner);
extern void grammar__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void grammar_lex_destroy(yyscan_t scanner);
extern char* grammar_get_text(yyscan_t scanner);

extern yyscan_t grammar__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListJob reverseListJob(ListJob l)
{
  ListJob prev = 0;
  ListJob tmp = 0;
  while (l)
  {
    tmp = l->listjob_;
    l->listjob_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListWord reverseListWord(ListWord l)
{
  ListWord prev = 0;
  ListWord tmp = 0;
  while (l)
  {
    tmp = l->listword_;
    l->listword_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  ListJob listjob_;
  Input input_;
  Job job_;
  CommandLine commandline_;
  Pipeline pipeline_;
  ListWord listword_;
  CommandPart commandpart_;
  OptRedir optredir_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, grammar_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _AMP     /* & */
%token          _SEMI    /* ; */
%token          _LT      /* < */
%token          _GT      /* > */
%token          _BAR     /* | */
%token<_string> T_Word   /* Word */

%type <listjob_> ListJob
%type <input_> Input
%type <job_> Job
%type <commandline_> CommandLine
%type <pipeline_> Pipeline
%type <listword_> ListWord
%type <commandpart_> CommandPart
%type <optredir_> OptRedir

%start Input

%%

ListJob : Job { $$ = make_ListJob($1, 0); }
  | Job _SEMI ListJob { $$ = make_ListJob($1, $3); }
;
Input : ListJob { $$ = make_StartInput($1); result->input_ = $$; }
;
Job : CommandLine { $$ = make_FGJob($1); }
  | CommandLine _AMP { $$ = make_BGJob($1); }
;
CommandLine : Pipeline OptRedir { $$ = make_CmdLine($1, $2); }
;
Pipeline : CommandPart { $$ = make_SingleCmd($1); }
  | CommandPart _BAR Pipeline { $$ = make_PipeCmd($1, $3); }
;
ListWord : T_Word { $$ = make_ListWord($1, 0); }
  | T_Word ListWord { $$ = make_ListWord($1, $2); }
;
CommandPart : ListWord { $$ = make_Cmd($1); }
;
OptRedir : /* empty */ { $$ = make_NoRedir(); }
  | _LT T_Word _GT T_Word { $$ = make_InOutRedir($2, $4); }
  | _GT T_Word _LT T_Word { $$ = make_OutInRedir($2, $4); }
  | _GT T_Word { $$ = make_OutRedir($2); }
  | _LT T_Word { $$ = make_InRedir($2); }
;

%%


/* Entrypoint: parse Input from file. */
Input pInput(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.input_;
  }
}

/* Entrypoint: parse Input from string. */
Input psInput(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.input_;
  }
}



